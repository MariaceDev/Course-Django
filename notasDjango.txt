
NUEVO PROYECTO
django-admin startproject holamundo

Crea un archivo manage.py y una carpeta holamundo, que una aplicación que se gestiona como un paquete.
El directorio raíz que se crea como defecto tiene el mismo nombre que el proyecto.

manage.py nos permite gestionar el proyecto, no hay qie tocar, se encarga de poner a nuestgra disposición las instrucciones de consola para poder operar.

En la carpeta está toda la estructura de archivos: todas las aplicaciones (carpetas) tienen:
- un _init_.py, para poder gestionar cada aplicaicón com unnpaquete
- asgi.py y wsgi son archivos auxiliares, que nos van a servir para ayudarnos por ejemplo, con el servidor y otras acciones ausiliares.
- urls.py: asocia las urls con las vistas que los gestionan. Es un array con los path. Aquí escribiremos todas las rutas y las vistas, también  los templates.
- settings.py: para establecer las configuraciones del paquete. Por ejemplo: hay un array con las apps instaladas, gracias a que es un framework vienen ya instaladas

1.5 PRIMER HOLA MUNDO: CIRCUITO COMPLETO

- Creamos una archivo de vistas para controlar la ruta y devolver un mensaje http para poder comprobar el circuito completo de esta arquitectura.
- Entramos en la terminal y creamos la estructura de base de 11:32 03/07/2023datos:para ello migra los modelos de datos a nuestro sistema de permanencia de datos a través del comando "migrator". Lo tendremos que hcer cada vez que modifiquemos la estructura de datos, al inicio y cada vez que trabajemos con él.
- Primero debemos llamar al archivo manage.py para hacer cualquier acción en la terminal y luego le solicitamos el comando ejecutar
- Entonces ejecutamos el comando: python manage.py migrate (tienes que colocarte en la ruta correcta)
- Para ver la db en vs instalamos sql tools y sql viewer
- Para continuar, podemos usar el servidor de django llamando desde el terminal: python manage.py runserver
- Entonces nos levanta un servidor en el puerto 8000, si seguimos el link veremos la página de django
- Para interrumpir el servidor usamos "cntrl c".
- Necesitamos un archivo de vistas, recordamos: las url apuntan a las vistas y estas trabajan con los modelos y estos devuelven los template.
- Entonces creamos un views.py que es donde vamos a declarar las vistas con las que estamos trabajando.
- Las vistas contienen la lógica y solo son diferentes funciones a las que se asociaran las url.
- Creamos la primera vista: 
#las vistas siempre van a tener un parámetro que es el request, la petición de ejecutar esta vista
#En este ejemplo nos saltamos los modelos y las plantillas con las que trabajaremos más adelente

from django.http import HttpResponse

def saludo(request):
    return HttpResponse("Hola mundo")

# Ya tenemos la vista creada, ahora necesitamos asociar una ruta que ejecute la vista. 
# Para ello nos vamos el urls.py y la definimos: path('saludo/', views.saludo, name='saludo') #es muy imprtante terminar con "/"
 Además, tenemos que importar la views: from . import views

- Levantamos de nuevo el servidor y seguimos el link. Aparece de inicio un error y es normal, porque no tenemos ninguna ruta en la raiz del proyecto.
- Las que exiten son admin y saludo. entonces ejecutamos la ruta saludo en la barra del navegador añadiendo: /saludo
- YA TENEMOS NUESTRO PRIMER CIRCUITO

2.1 RUTAS CON PARÁMETROS

Esto nos permitirá recepcionar variables a través de la url que puede posteriormente utilizar en nuestra vista.

- Hasta ahora solo hemos definido rutas estáticas, no reciben ninguan información a través de la url.
- si hacemos un blog, por ejemplo, y queremos recibir el id de la noticia: path("post/3") o una función para pedir la edad path("adulto/edad")
path('adulto/<int:edad>/<int:altura>/'): asi se introducen las variables. después lo asociamos a na vista:  path('adulto/<int:edad>/<int:altura>/' views.adulto, name='adulto')

- Hacemos una prueba:

path('adulto/<int:edad>/', views.adulto, name='adulto')

def adulto (request, edad):
    if(edad >= 18):
        return HttpResponse ("Es mayor de edad.")
    else:
        return HttpResponse ("No eres mayor de edad.")



http://127.0.0.1:8000/adulto/14/
No eres mayor de edad.


2.2 USO DE PLANTILLAS

Qué son las plantillas y configuramos nuestro primer template.

Creamos un nuevo proyecto: django-admin startproject plantillas

1º.- Migramos toda la estructura: python manage.py migrate.
2º.- Levantamos servidor: python manage.py runserver.
3º.- Creamos un views.py 
4ª.- Creamos un path: path('simple', views.simple, name='simple') e importamos el views.py
5º.- Creamos una vista nueva, pero en vez de devolver un http, ddevolvemos un template que muestre la información al usuario

Los template o plantillas es un trozo de texto que aislamos dentro de un archivo, que, de forma habitual será HTML. 
Las plantillas contienen la parte visual de proyecto, la lógica estará en las views.
Carga de un template:
1- Establecer el directorio donde vamos a colocar las plantillas, que será en: settings.py
Ahí hay un array de direcciones para buscar donde se encuentran la plantillas:  'DIRS': ['templates']
2- Creamos en la raíz una carpeta con el mismo nombre.
3- Cremos un archivo para views que se va a llamar simple.html, donde podemos escribir nuestro código html
4- Volvemos al archivo views para terminar el return, que debe devolver la plantilla. Hay diferentes métodos, como haciendo la carga de un archivo.
Pero django nos facilita con atajos a través del método render: from django.shortcuts import render
Después terminamos la vista usando render al que le pasamos tres parámetros: el request o petición, la ruta hacia el html y el contexto, que es un diccionario, se lo pasamos vacío porque esta plantilla no necesita nada para funcionar):

def simple(request):
    return render(request, 'simple.html', {})

2.3. USO DE CONTEXTOS

1.- Hacemos un nuevo path al que llamamos dinámico.
2.- Definimos la vista en views con una función. Para ello hacemos uso de una variable pasada por paramertro. Para en el path solicitamos un string llamado nombre:
 
	path('dinamico/<str:name>/', views.dinamico, name='dinamico')

3.- Creamos un nuevo archivo HTML llamado dinamico, utilizando la plantilla que hemos creado.
4.- Para la vista, utilizamos un return con render al que le pasamos los tres parámetros definidos en el apartado anterior, con la diferencia de que, en vez de pasar un diccionario vacío, le pasamos una variable llamada contexto que contendrá el diccionario.

	def dinamico (request, name):
    	  context = {'name': name}
    	  return render(request, 'dinamico.html', context)

5.- En el contexto lo que hacemos es el uso de un par clave:valor, lo que hacemos es uso de la clave para que pinte el valor. Para ello, en HTML lo que hacemos es una doble llave para colocar el name. Así, colocamos el valor del contexto, hacienod uso de la información contextual:
	
	    <h1>Hola {{name}}</h1>

6.- Podemos pasar todo tipo de datos, incluso objetos y clases con sus métodos. No solo tipo de datos primitivos.
7.- Porbamos a pasar un array:

	def dinamico (request, name):
    	  categories = ['code', 'design', 'marketing']
    	  context = {'name': name, 'categories': categories}
    	  return render(request, 'dinamico.html', context)
         ____________________________________________________

  	<body>
          <h1>Hola {{name}}</h1>
          <h3>Categorías</h3>
          <p>{{categories}}</p>   
    	</body>

Resultado:

Hola Mari Carmen
Categorías
['code', 'design', 'marketing']

Como podemos ver, nos pinta la estructura, pero lo que queremos es simplemente acceder a la imformación de la estructura, para ello tendremos que recorrer la estructura para pintar la info sin corchetes, de forma correcta.


2.4. BUCLES Y CONDICIONALES EN PLANTILLAS

Es importante que no cargemos acciones de lógica en las plantillas (HTML), igualmente no debemos pintar (visualización) en las vistas.

Para recorrer las estructuras, BUCLES, debemos usar una nomenclatura diferente {% %}. La estructura quedaría de la siguiente manera:

   <body>
        <h1>Hola {{name}}</h1>
        <h3>Categorías</h3>
        <ul>
            {% for category in categories %} <!--Hacemos un foreach para recorrer el array-->
                <li>{{category}}</li> <!--Escribimos código con la imformación que usamos, es un literal-->
            {% endfor%} <!--Cerramos el foreach-->
        </ul>  
    </body>

Y el resultado:

Hola Mari Carmen
Categorías
   · code
   · design
   · marketing

También, podemos incorporar CONDICIONALES:

   <body>
        <h1>Hola {{name}}</h1>
        <h3>Categorías</h3>
        <ul>
            {% for category in categories %} <!--Hacemos un foreach para recorrer el array-->
                {% if category == 'code' %} <!--Incorporamos el if con la condición-->
                    <li><b>{{category}}</b></li> <!--Le indicamos que lo pinte en negrita-->
                {% else %} <!--Si no se cumple la condición: -->
                    <li>{{category}}</li> <!--Escribimos código con la imformación que usamos, es un literal-->
                    {% endif %} <!--Cerramos el if-->
            {% endfor %} <!--Cerramos el foreach-->
        </ul>  
    </body>


2.5. COMENTARIOS Y FILTROS

En las plantillas podemos escribir COMENTARIOS que no van a ser pintados en la consola: <!---->, aparece en la consola de Google cuando inspeccionamos el código.

Hay dos formas:

-Comentario simple: {# #}
- Comentario multilinea: {% coment %}
                          Hola, soy comentario multilínea
                         {% endcoment %}



Django ofrece una gran cantidad de filtros para realizar especificaciones. Por ejemplo, finaliza el bucle y queremos colocar un h5 con el total de categorías, aunque no tengamos el length, podemos usar un filtro:
	
	<h5>Total de categorías: {{categories|length}}</h5>

Y el resultado sería:

Hola Mari Carmen
Categorías
   · code
   · design
   · marketing

Total de categorías: 3

Otro ejemplo, que lo coloque en mayúsculas:

	<li><b>{{category | upper}}</b></li>

También se pueden anidar

	<li><b>{{category | upper | lower | capitalize | title }}</b></li>


2.6. ARCHIVOS ESTÁTICOS

1.- Creamos un nuevo proyecto: django-admin startproject estaticos
2.- Migramos el sistema: python manage.py migrate
3.- Corremos el servidor: python manage.py runserver
4.- Generamos un circuito para caragr una plantilla:

	1. setting.py e indicamos el directorio 'templates'
	2. Creamos el directorio 'templates'
	3. Accedemos al archivo de rutas y cargamos una vista
		1. Para ello generamos el archivo de vistas: views.py
		2. Creamos una vista llamada estaticos que, por ahora, dejamos vacía:
			def estaticos(request):
    				return ""
	4. Colocamos en la urls la importación de dicho archivo:
		from . import views
		path('estaticos/', views.estaticos, name='estaticos')
	5. El archivo views.py importamos el método render para poder pintar las vistas:
		from django.shortcuts import render
		def estaticos(request):
    			return render (request, 'estaticos.html', {})
	6. Creamos la plantilla: estaticos.html


 ¿Cómo hacemos la importación de archivos estáticos en una plantilla?

1. Vamos al archivo setting.py y en STATIC_URL = 'static/' es la ubicación donde pondremos los archivos estáticos.
Por defecto se coloca en la raíz del proyecto. Nosotros lo haremos así:
	- Accedemos a nuestro proyecto y creamos un directorio donde irán todos los archivos js, css, imágenes, etc., que usaremos en el proyecto.

2. Creamos el archivo estático dentro de la carpeta, como por ejemplo un css: style.css
3. Indicamos a la plantilla, antes que el doctype, que va a hacer uso de elementos estáticos: 
		{% load static %}
4. Para cargar el css en el HTML no se hace de la manera normal, sino utilizando la nomenclatura de django que va a especificar dentro de l aplantilla qué archivos van a ser de carga estática:
	  <link rel="stylesheet" type="text/css" href="{% static 'style.css' %}" >
5. Comprobamos el navegador y no se ha caragdo correctamente debido a la configuración, porque tenemos que indicar los directorios que va a tener la configuración sobre los archivos estáticos.
Esto se hace añadiendo una variable de entorno más en el setting. La variable es:
	STATICFILES_DIRS = [#recibe un array con las url que vamos a tener
	BASE_DIR / 'static', #añadimos el directorio base junto con static, que es lo que hemos definido anteriormente
	'/var/www/static', #añadimos este directorio, que será el que albergará los archivos estáticos una vez hagamos el deploy, aunque todavía no esté creada
	]

2.7. HERENCIA DE PLANTILLAS

Nos va apermitir modularizar nuestro HTML y evitar la reutilización de código, para no concurrir en duplicidad de etiquetas o módulos.
Creamos un nuevo proyecto con la views, la carpeta template, static y todo el recorrido para cargar una plantilla y el contenido estático que necesite.

Añadimos una nueva ruta, porque nuestro proyecto puede necesitar varias rutas:
	path('ejemplo/', views.ejemplo, name='ejemplo'),
Y le creamos una vista:
	def ejemplo (request):
    return render (request, 'ejemplo.html', {})
Y otra ruta más para que se entienda bien, con su vista y su template, a la que llamaremos 'otra'.

Para rellenar los template ejemplo u otra, estamos copiando contenido y rellenando. Esto no es una buena práctica, es un problema.
Para evitarlo, tenemos las herencias. Indicamos que una plantilla va a heredar de una plantilla padre que le puede heredar una estructura.
 así estandarizamos el contenido del layout.

Para hacerlo, creamos un nuevo directorio, dentro de template, que se llama de diferentes maneras ( app, base o layout) y dentro creamos una plantilla: base.html.
Rellenamos la platilla con las etiquetas básicas y le añadimos un archivo css.

Ahora el siguiente paso es extender el contenido de la base a las otras plantillas. Para ello especificaremos qué partes pueden ser extendidas, es decir, las que van a cambiar por medio de bloques:
	{% block styles %}{% endblock %} -Para incluir más hojas de estilo
	{% block title %}{% endblock %} -Para cambiar el título
	{% block content %}{% endblock %} -PAra cambiar contenido
	{% block scripts %}{% endblock %} - Para incluir diferentes scripts

El siguiente paso será cómo pueden el resto de plantillas extender la información de la base:
	{% extends './layout/base.html' %}
Ahora, por defecto, tendrán todo el contenido de la base, que se mostrará en herencia.

Y para extender el contenido que queremos cambiar bastaría con definirlo:
	{% block title %}HERENCIA{% endblock %}

	{% block content %}
   	 <h1> HERENCIA</h1>
	{% endblock %}

2.8. ENLACE E INCLUSIÓN

Primero creamos un path para incluir el directorio raíz ddel proyectos:
	 path('index/', views.index, name='index')
Y definimos la vista:
	def index (request):
    		return render (request, 'index.html', {}) 
Creamos el archivo index.html dentro de la carpeta template y extendemos la plantilla base.

Empezamos con los links, haciendo las vinculaciones a través de los links y no escribiéndolo sobre la barra de direcciones.
Para ello, vamos al base.html y definimos ahí los enlaces. 
Para hacer los enlaces utilizamos los nombres definidos en el path, también la ruta del path, aunque es un codigo más difícil de mantener si hubiera que modificarlo.
El nombre es mucho más fácil de modificar porque solo habría que cambiarlo una vez:

	 <li><a href="{% url 'herencia' %}">Herencia</a></li>

Para modularizar mucho más el código podemos hacer uso de los includes. Dentro de layouts hacemos una nueva carpeta llamada 'parcials' y dentro creamos una plantilla que sea un menú html.

Cortamos el nav del archivo de la base y lo pegamos en el menu.html.
Ahora o que queremos es que la base extienda el menú con el include:

	  {% include 'layouts/partials/menu.html' %}

2.9. DOCUMENTACIÓN OFICIAL

2.10. PRÁCTICA DE PLANTILLAS

________________________________________________________________________________________________________________
________________________________________________________________________________________________________________


3.1. MODULARIZACIÓN

Creamos la primera aplicación dentro de un proyecto ya creado en Django:

1. django-admin startproject modularizacion
2. creamos una nueva aplicación: 
	python manage.py startapp comentarios #el último es el nombre que hemos elegido para la app
3. la app funciona como otra aplicación y contiene otros archivos como el views, otro para test, para modularición, todos los iremos trabajando
4. contiene un directorio de migraciones.
5. Si queremos reutilizar la app de comentarios en nuestro proyecto práctica plantillas, tan solo tenemos que llevarnos el directorio al proyecto.
6. Tenemos que decirle a django cuáles de las aplicaciones que tenemos van a estar instaladas en el proyecto, es decir, cuáles son las que vamos a utilizar.
Esto lo hacemos en el archivo:
		 settings.py => INSTALLED_APPS => 'comentarios',
Como habita en la raíz del proyecto es suficiente con poner el nombre de la app. Como comentarios funciona como un paquete, se instala.

Para comprobar si la app está correctamente instalada ejecutamos en consola:
	python manage.py check comentarios
Respuesta: System check identified no issues (0 silenced).
Significa que ha detectado la app y no hay fallos en ella.

RESUMEN RECORRIDO ARQUITECTURA

1. El USUARIO realiza una petición a una URL que nosotros gestionamos con el archivo urls.py
2. Este urls.py deriba a una VIEWS.py que contendrá la lógica a través de funciones def.
3. El views.py puede que necesite realizar acciones con los datos del proyecto, esto lo hace a través de los MODELOS.
4. Los modelos a través del ORM harán las gestiones con el motor de base de datos para garantizar la persistencia.
5. Devuelve las informaciones a la VISTA, que renderiza, pinta un TEMPLATE, que es la información que recibe el usuario, la WEB servida en su navegador

Este patrón de arquitectura MODEL TEMPLATE VIEW (MTV) es una variación del (MVC). Las principales diferencias son:

	- En el patrón MVC, la Vista se encarga de la presentación de los datos al usuario, mientras que en el patrón MTV, 
	  la Plantilla se encarga de esta responsabilidad.
	- En el patrón MVC, el Controlador es responsable de recibir las acciones del usuario y actualizar el Modelo y la Vista en consecuencia. 
	- En el patrón MTV, la Vista se encarga de la lógica de negocio y la interacción entre el Modelo y la Plantilla.

3.2. MODELADO DE DATOS

Los modelos van a ser elementos que van a estar representando datos que el ORM se va a encargar de gestionar dentro de nuestro sistema de bases de datos.
El ORM de Django nos va a abstraer del ORM, por ejemplo consultas sql, etc. Podremos trabajar cada uno de los elementos como si fuese un objeto: en lugar de crear
tablas, crearemos clases en python. Estas clases extenderán un modelo y van a perminirnos crear objetos. El ORM de Django lo que hará por detrás es generar una tabla
en nuestro sistema de permanencia de datos por cada clase que creemos. Nosotros solo creamos clases y django una tabla, donce cada atributo corresponderá una tabla.


Comenzmos por el ejemplo más sencillo: un comentarios.

Trabjanmos con MODELS: cada modelo es una clase y empezamos por una:

	class Comment (models.Model): #Por convención, los nombres de las clases empiezan en mayúscula y van en singular

   		 def __str__(self):
      		  return

Cuando migremos esto, django detectará la clase comments y creará una tabla en la DB.
Ejemplo:

	class Comment (models.Model):

    		name = models.CharField(max_length=255, null=False)
    		score = models.IntegerField(default=3)
    		comment = models.TextField(max_length=1000, null=True)

    		def __str__(self):
        		return self.name

Como hemos hecho una modificación del modelo, debemos hacer una migración. En Django se hace de la siguiente manera:

1. Pedimos que la clase sea traducida a sql:
	python manage.py makemigrations
Entonces nos crea este archivo:  comentarios\migrations\0001_initial.py

2. Ejecutamos la migración con: python manage.py migrate
Si vemos la DB, aparece la estructura habitual más una tabla llamada comentarios_comments (nombre_app.nombre_clase)
Si pulsamos vemos la tabla con los campos que hemos definido, junto con un id que es automático si no se define.
Podemos modificar el modelo sin problema, solo que hay que hacer la migraci´`on para que se guarden los cambios:
	python manage.py makemigrations
	python manage.py migration
Para no compremer la integridad de la DB, no debemos añadir campos que no pueden ser nulos después de haber creado la tabla, porque los que se hayan añadido
con anterioridad no van a estar rellenos. Para arreglar ese problema debemos añadir otro campo que puede ser, por ejemplo: null=True o añadir un valor por defecto: deafult=""

Los archivos.py que se generan con un número delante sirven para controlar la versión que va subiendo al sistema. Lo hace gracias a que una de las tabla que genera para funcionar es 
migration, donde guarda toda la evolución de la DB. Es muy útil porque podemos hacer un roll back para hacer algún cambio.


3.3. DELEGACIÓN DE RUTAS

Comprobamos el funcionamiento del modelado de datos en nuestra app.
Vemos como comunicamos todas las acciones a nuestro proyecto raíz manteniendo una modularización de nuestra estructura.
Una buena práctica es que cada aplicación contenga sus propias urls y hacer que el proyecto raíz sepa cómo acceder a ellos.

1. Dentro de la app (comentarios) creamos un archivo urls.py
2. Copiamos la estructura de la url.py general (modularizacion) y la dejamos limpia
3. Creamos una ruta de prueba, importamos views y creamos una vista junto con el template, solo un hola mundo para comprobar que el circuito funciona bien
4. Para que nuestro directrio general pueda leer las urls de las app, debemos hacer:
	- Importar la librería include: from django.urls import path, include
	- Crear el path de la carpeta de la app junto con el include:
		path('Comment/', include('commentarios.urls')),

3.4. CREACIÓN Y BORRADO DE DATOS

1. Creamos una ruta y una vista con el nombre create
2. En la vista importamos el modelo Comment que habíamos creado
3. En la vista, dentro de la función, creamos un objeto:
	 comment = Comment(name:'Manuela', score:5, comment: 'Este es un comentario')
4. Lo guardamos en la DB:
	comment.save()

5. Otra manera de crear sin el save, se guarda de manera automática:
	comment = Comment.objects.create(name='Mina')
6. Cuando creamos, para ejecutar la llamada debemos RECARGAR la página

7. Para borrar hacemos un path nuevo y la vista:
	path('delete', views.delete, name='delete'),

8. Para borrar un objeto primero debemos encontrarlo:
	def delete (request):
    		comment = Comment.objects.get(id=1) #Para encontarlo
    		comment.delete() #Para borrarlo

    		return HttpResponse('Ruta para probar los borrados')

9. Otra manera de hacer borrados es con los filters. Directamente, sin instancia:
	Comment.objects.filter(id=4).delete()


3.5. ESTRUCTURA Y CLAVES FORÁNEAS

Creamos un nuevo proyecto:

1. django-admin startproject my_blog

2. Una nueva app dentro del proyecto: 
	python manage.py startapp post

3. Metemos la app dentro del setting-py, en INSTALLED_APP = ['post']

4. Comprobamos que se ha creado de manera correcta:
	python manage.py check post
	System check identified no issues (0 silenced).

5. En la aplicación de post creamos el urls.py

6. Creamos la url para la app post y así delegar las rutas de post a su archivo urls.py
	from django.urls import path, include #Este include hay que escrbirlo
	path('post/', include('post.urls'))

7. Definimos el archivo urls.py de la app post que, de momento, dejamos vacío (hay que crearlo dentro del directorio de la app):
	from django.urls import path

	urlpatterns = [
	]

8. Definimos los modelos creando una clase por cada uno de los modelos:

	1. Clase autor:
		class Author(models.Model):
    			name = models.Charfield(max_length=200)
    			email = models.EmailField()

    			def __str__(self):
        			return self.name

	2. Clase para las entradas en el blog que relacionamos con el autor gracias a la foreing key:
		class Entry (models.Model):
    			author = models.ForeignKey(Author, on_delete=models.CASCADE) #Declaramos la clave foránea y l decimos que, si borramos al autor, se borren también los post para conservar la integridad de los datos
    			headline = models.CharField(max_length=255)
    			body_text = models.TextField()
    			public_date = models.DateTimeField(default = date.today())
    			rating = models.IntegerField(default=5)

    			def __str__(self):
        			return self.headline

	3. Migramos los datos:
		- python manage.py makemigrtions
		- pythin manage.py migrate

	4. Comprobamos que se ha creado la DB


3.6. SEEDING Y PAQUETES

Ahora, poblaremos una base de datos con un factoring que nos permite intrpducir datos falsos de prueba (faking) para poder hacer consultas y ver cómo funciona la app 	

1. Hacemos la carga del paquete de forma externa. En Github podemos ver las intrucciones de instalación de django seed, que son:

	- pip install django-seed #si hubiera problemas en la instalación por colisión con diferentes versiones de Django, podemos poner delante de la instrucció  la pabara "python"
	- En setting.py colocamos la app:
		INSTALLED_APPS = [
    			...
    			'django_seed',
		]
	- Comprobamos que está instalada:
		python manage.py check django_seed

2. Poblamos la DB según las instrucciones del readme de la app en Github:
	-python manage.py seed api --number=15 #Donde api es el nombre de la app y el number el número de registros que queremos introducir
	
   Nos encontramos con un problema, porque no encuentra el módulo 'psycopg2' y miramos en Github la solución  en el apartado issues y hay otra persona con el mismo problema que recomienda esto:
	pip install psycopg2-binary

   Volvemos a ejecutar la instrucción anterior:
	python manage.py seed post --number=50

3.7. CONSULTA DE DATOS I

Vamos a la aplicación Post y trabajamos la vista que va a generar la consulta:

1. Creamos la ruta y la asociamos a a la vista:
	- En el urls.py: path('queries/', views.queries, name="queries")
	- En views.py: 
		1. importamos 'from django.http import HttpResponse' para usar las respuestas HTTP ya que vamos a estar trabajando directamente las consultas, no vamos a renderizarlas en un template
		2. Creamos la función: 
			def queries (request):
    				return HttpResponse("Consulta realizada")

2. Realizamos las consultas:

-Primero entramos en el proyecto (cd my_blog), comprobamos que hemos hecho todas las migraciones (python manage.py migrate) y levantamos el servidor (python manage.py runserver)
- Generamos el template para visualizar los datos:
	1. Creamos la carpeta 'templates' y dentro otra llamada 'post' donde generamos la vista queries.html
	2. En settings.py especificamos los datos:
		  'DIRS': ['templates']
	3. Creamos estructura de html5 y dejamos prepardo para visualizar los datos
- Empezamos a generar las vistas en views:
	1. Importamos los modelos que necesitaremos y quitamos el httpresponse:
		from .models import Author, Entry
	2. Redefinimos la función y comenzamos a hacer consultas:
		
		def queries (request):
    			# Obtener todos los elementos
    			authors = Author.objects.all()

    			# Obtener datos filtrados por condición
    			filtered = Author.objects.filter(email='aprilcontreras@example.org')

    			# Obtener un único objeto (filtrado)
    			author = Author.objects.get(id=1)

    			# Obtener los 10 primeros elementos
    			limits = Author.objects.all()[:10]

    			# Obtener 10 elemetos saltando los 5 primeros
    			offsets = Author.objects.all()[5:10] 
			
			# Obtener todos los elementos ordenados
    			orders = Author.objects.all().order_by('email')

    			# Obtener todos los elementos cuyo id sea menor o igual a 15
    			filtereds2 = Author.objects.filter(id__lte=15)

    			#Obtener todos los autores que contienen en su nombre la palabra 'yes'
    			contains = Author.objects.filter(name__contains='yes')
  
    				return render(request, 'post/queries.html', {'authors': authors, 'filtered': filtered, 'author': author, 'limits': limits, 'offsets':  offsets, 'orders': orders, 'filtereds2': filtereds2, 'contains': contains})


	__lte: menor o igual (lower than equals) #filter.(id__lte=15)
	__gte: mayor o igual (greater than equals)
	__lt: menor que (lower than)
	__gt: mayor que (greater than)
	__contains: contiene
	__exact: exacto


	3. Lo pintamos en el HTML para que se muestre el resultado:

	<body>
        <h3>Autores que contienen la palabra 'yes'</h3>
        <ul>
            {% for contain in contains %}
                <li>{{ contain }}</li>
            {% endfor %}
        </ul>
        <h3>Elementos con id menor o igual que 15</h3>
        <ul>
            {% for filtered2 in filtereds2 %}
                <li>{{ filtered2.email }}</li>
            {% endfor %}
        </ul>

        <h3>Elementos ordenados por email</h3>
        <ul>
            {% for order in orders %}
                <li>{{ order.email }}</li>
            {% endfor %}
        </ul>

        <h3>Busqueda limitada y con offset</h3>
        <ul>
            {% for offset in offsets %}
                <li>{{ offset.email }}</li>
            {% endfor %}
        </ul>


        <h3>Obteniendo los 10 primeros (limit)</h3>
            <ul>
                {% for limit in limits %}
                    <li>{{ limit.email }}</li>
                {% endfor %}
            </ul>

        <h3>Obteniendo un único elemento (filtrado por id)</h3>
            <p>{{author}}</p>

        <h3>Buscando autor donde email =  aprilcontreras@example.org</h3>
            <ul>
                {% for elm in filtered %}
                    <li>{{elm.name}} | {{elm.email}}</li>
                {% endfor %}
            </ul>

        <h3>Todos los autores</h3>
            <ul>
                {% for author in authors%}
                    <li>{{author.name}} ( {{author.email}})</li>
                {% endfor %}
            </ul>
        <h3>Total autores: {{ authors|length }}</h3>
        
    </body>

	
24. ACTUALIZACIÓN DE DATOS

Una actualización de datos es tomar el objeto, realizar los cambios y volver a guardarlo.
Crearemos una nueva url controlada por una vista que va a realizar una actualización. DEntro de post:
	path('update/', views.updat, name="update")

Y para la vista creamos la función update:

	def update(request):
    		author = Author.objects.get(id=1) #Primero obtenemos el objeto
    		author.name = "Manuela" #Cambiamos el nombre
    		author.email = "manuela@demo.com" #Cambiamos el mail
    		author.save() #Guardamos
    		return HttpResponse("Modificado")

25. RELACIONES 1 A 1

- Creamos un nuevo proyecto llamado "relations" junto con una app "onetoone".

- En este ejemplo vamos a establecer una relación entre lugares y restaurantes, que tendrán una relación 1 a 1.

	1. Añadimos la app en el setting.py y comprobamos que se ha instalado correctamente con el check
	2. Delegamos las rutas en urls.py > urlpattern: path('one/', include('onetoone.urls'))
	3. Creamos el archivo urls.py en la app onetoone que se encarga de hacer la gestión junto con su estructura:

		from django.urls import path, include

		urlpatterns = [
   
		]

	4. Migramos la estructura principal: python manage.py migrate
	5. Levantamos el servidor para comprobar que todo ha ido bien: python manage.py runserver

- Comenzamos con el modelado de datos en el archivo models.py:

from django.db import models

class Place(models.Model):
    name = models.CharField(max_length=50)
    address = models.CharField(max_length=80)

    def __str__(self):
        return self.name
    
class Restaurant (models.Model):
    place = models.OneToOneField(Place, on_delete=models.CASCADE, primary_key=True)
    number_employees = models.IntegerField(default=1)

    def __str__(self):
        return self.place.name #cuando relacionamos las clases, podemos acceder a la información (atributos, métodos) de esas clases. Es una forma sencilla de relacionar los modelos


- Creamos un nuevo path:
	 path ('create/', views.create, name='create')

- Definimos la función en la vista:
	from django.shortcuts import render
	from django.http import HttpResponse

	def create(request):
    		return HttpResponse("Datos creados")

- Hacemos la migración de la información del modelo:
	python manage.py makemigrations (crea los modelos)
	python manage.py migrate (migra l ainformación)

- Creamos los diferentes elementos a través de objetos:

	1. En el archivo views.py importamos los modelos:
		from models import Place, Restaurant
	2. Creamos los modelos con sus atributos y relacionamos el restaurante con el lugar (place=place): #Esto también se puede hacer con Place.objets

		def create(request):
    			place = Place(name="Lugar 1", address="Calle Demo")
    			place.save()

    			restaurant = Restaurant(place=place, number_employees=8)
    			restaurant.save()

   			return HttpResponse(restaurant.place.name)
	Levantamos el servidor para comprobar que funciona correctamente.
	Comprobamos la DDBB y vemos que se ha introducido el registro y que, en Restaurant, aparece una primary key con un id que la relaciona con un Place.



26. RELACIONES MUCHOS A 1

Un elemento puede tener muchos de otro, pero ese otro solo puede tener uno del anterior. Realizamos una práctica con Reportero y Artículos.

- Dentro del proyecto relations, creamos una nueva aplicación many to one:
	python manage.py startapp manytoone

- Damos de alta la aplicación en el settings.py de relations y comprobamos la correcta instalación con check
- Delegamos los path con include: path('many/', include('manytoone.urls')) y creamos el urls.py en la app nueva
- Procedemos al modelado de datos:

from django.db import models

class Reporter (models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
    email = models.EmailField()

    def __str__(self):
        return self.email
    

class Article (models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE)

    def __str__(self):
        return self.headline


- Debemos migrar el cambio en los modelos:
	python manage.py makemigrations
	python manage.py migrate

- Empezamos a trabajar la vista:
	1. Importamos los modelos creados: from .models import Reporter, Article
	2. Creamos un artículo y un reportero:
		from .models import Reporter, Article
		from datetime import date

		def  create(request):
    		  rep = Reporter(first_name='Mina', last_name='Repiso', email='mina@demo.com')
    		  rep.save()

    		  art1 = Article(headline='Los modelos de lenguaje', pub_date = date(2023,1,8), reporter=rep)
    		  art1.save()
    		  art2 = Article(headline='Machine learning', pub_date = date(2023,2,8), reporter=rep)
    		  art2.save()
    		  art3 = Article(headline='Frame para metáforas ontológicas', pub_date = date(2023,3,8), reporter=rep)
    		  art3.save()

    		return HttpResponse("Creado")

	3. Creamos un elemento de query y a hacer consultas sobre todo:

	result = art1.reporter.first_name
    	result1 = rep.article_set.all() #nombre del article y set, después todo igual que en las consultas
    	result2 = rep.article_set.filter(headline='Los modelos de lenguaje')
    	result3 = rep.article_set.count()

	return HttpResponse(result3)

27. RELACIONES MUCHOS A MUCHOS

- Creamos una nueva aplicación.

El ejemplo será: un articulo puede estar en muchas publicaciones y una publicación va a poder encontrarsse en muchos artículos.

- Modelamos los datos:

** Para delcarar las relaciones many to many solo hace falta indicarlo en una clase, en este caso en la clase Article

from django.db import models

class Publication(models.Model):
    title = models.CharField(max_length=30)

    def __str__(self):
        return self.title
    


class Article(models.Model): #Como trabajamos en aplicaciones autocontenidas, no nos va a dar ningún problema que ya tengamos una clase Article en otra aplicación
    headline = models.CharField(max_length=100)
    publicacions = models.ManyToManyField(Publication) #Para definir el many to many, no hace falta el delete porque e crea una tabla a parte
    
    def __str__(self):
        return self.headline

- Trabajamos con los datos en la vista:
from django.shortcuts import render
from django.http import HttpResponse

def create (request):
    return HttpResponse("...")

- Migramos los modelos

- Definimos la vista:
**Para poder relacionar de muchos a muchos es muy importante debemos guardar primero los dos elementos que vamos a relacionar

from django.shortcuts import render
from django.http import HttpResponse
from .models import Article, Publication

def create (request):
    art1 = Article(headline="Primera parte: Los modelos de lenguaje")
    art1.save()
    art2 = Article(headline="Segunda parte: Los modelos de lenguaje")
    art2.save()
    art3 = Article(headline="Tercera parte:Los modelos de lenguaje")
    art3.save()
    
    pub1 = Publication (title="Primera publicación")
    pub1.save()
    pub2 = Publication (title="Segunda publicación")
    pub2.save()
    pub3 = Publication (title="Tercera publicación")
    pub3.save()
    pub4 = Publication (title="Cuarta publicación")
    pub4.save()
    pub5 = Publication (title="Quinta publicación")
    pub5.save(9)
    pub6 = Publication (title="Sexta publicación")
    pub6.save()
    pub7 = Publication (title="Séptima publicación")
    pub7.save()

    #Relacionamos ambas clases

    art1.publicacions.add(pub1)
    art1.publicacions.add(pub2)
    art1.publicacions.add(pub3)
    art2.publicacions.add(pub4)
    art2.publicacions.add(pub5)
    art3.publicacions.add(pub6)
    art3.publicacions.add(pub7)
    

    return HttpResponse("...")

- Trabajamos con los datos:

 	pub1 = Publication.objects.get(id=1)
    	result = pub1.article_set.all()
	art1.publicacions.remove(pub1) #Para eliminar relaciones



28. CONEXIÓN CON POSTGRESQL

En la documentación vienen todos los requerimientos de las DDBB: 

1. Creamos un nuevo proyecto
2. Nos descargamos la última versión de PostgreSQL
	- Creamos una DDBB vacía que luego conectaremos con DJango
	- Para conectar usamos los parámetros indicados en la documentación dentro del setting, cambiando a nuestros datos:

		
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "django_sample",
        "USER": "postgres",
        "PASSWORD": "django_sample",
        "HOST": "127.0.0.1",
        "PORT": "5432",
    }
}

	- Hacemos una migración para comprobar que se ha creado bien. Podemos mirar que se han creado las tablas.

29. PRÁCTICA MODELO DE DATOS: DISEÑO

Somos un desarrollador backend qie trabaja en un software de gestión de una multinacional.
Nos solicitan que crear una app en Django que debe hacer los siguiente:
	- Llevar un control de los empleados: nombre, dni, email, dirección, puesto de trabajo y la ubicación (localización de la frábrica en la que trabaja).
	- Su puesto de trabajo tenrá: el cargo, descripción del cargo y salario asociado.
	- El salario pueden pertener a uno o diferentes puestos de trabajo, incluirán siempre el bruto anual y si tienen asociada una paga extra en diciembre y junio.
	- Las ubicaciones (fábricas en las que pueden trabajar) vamos a registrar el nombre, la ubicación, el código postal y la pobración. Estarán agrupadas por país.

- Creamos un diagrama entidad relaciñon y formalizar las tablas en su tercera forma normal.

30. PRÁCTICA MODELADO DE DATOS: CODIFICACIÓN

Creamos un nuevo proyecto llamado 'practice_model' y, dentro, una app llamada 'company'.

Comenzamos con el modelado de la DDBB:

	1. Introducir postgres en el DATABASES del setting.py:

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "company",
        "USER": "postgres",
        "PASSWORD": "",
        "HOST": "127.0.0.1",
        "PORT": "5432",
    }
}

	2. Hacemos un migrate para comprobar que funciona y que se crean las tablas en la DB.
	3. Comenzamos el modelado en el archivo models.py junto con las foreing keys:

class Salary(models.Model):
    amount = models.IntegerField(blank=False, null=False)
    extra_jun = models.BooleanField(default=False)
    extra_dic = models.BooleanField(default=False)

    def __str__(self):
        return self.amount

class Job(models.Model):
    title = models.CharField(max_length=15, blank=False, null=False)
    description = models.TextFieldField(blank=False, null=False)
    salary = models.ForeignKey(Salary, on_delete=models.CASCADE)

    def __str__(self):
        return self.title
    
    
class Country(models.Model):
    name = models.CharField(max_length=15, blank=False, null=False)
    country_code = models.CharField(max_length=6, blank=False, null=False)

    def __str__(self):
        return self.name

    
class Location(models.Model):
    name = models.CharField(max_length=30, blank=False, null=False)
    country = models.ForeignKey(Country, on_delete=models.CASCADE)
    
    def __str__(self):
        return self.name
    
class Place(models.Model):
    name = models.CharField(max_length=30, blank=False, null=False)
    address = models.CharField(max_length=50, blank=False, null=False)
    zip_code = models.CharField(max_length=5, blank=False, null=False)
    location = models.ForeignKey(Location, on_delete=models.CASCADE)

    def __str__(self):
        return self.name

class Employee(models.Model):
    id_numbrer = models.CharField(max_length=10, blank=False, null=False)
    name = models.CharField(max_length=30, blank=False, null=False)
    last_name = models.CharField(max_length=30, blank=False, null=False)
    email = models.EmailField(max_length=30, blank=False, null=False)
    address = models.CharField(max_length=50, blank=False, null=False)
    job = models.ForeignKey(Job, on_delete=models.CASCADE)
    place = models.ForeignKey(Place, on_delete=models.CASCADE)

    def __str__(self):
        return self.name

	4. Introducimos un makemigration y, en el recién creado initial.py, aparece la migración
	5. Introducimos un migrate y se migra a la DDBB.

	


31. FORMULARIO HTML: GET

Hay dos maneras de crear formularios: tal como lo hacemos en HTML y los modelos de formularios que ofrece Django (el profesor prefiere los modelos)

Sirven los formularios HTML y los modelos que ofrece python. Es importante aislar los formaularios para que el código sea limpio y fácil de mantener.

1. Construimos un nuevo proyecto
2. Hacemos un migrate, porque vamos a trabajar sobre la misma carpeta que se ha creado con el proyecto.
3. Creamos un nuevo path en urls.py: path('form/', views.form, name='form')
4. Creamos el archivo views.py y dentro su función junto con la importación de render:

from django.shortcuts import render

def form(request):
    return render(request, 'form.html', {})

5. Creamos una nueva carpeta llamada template y, dentro, el form.html
6. En el archivo setting.py incluimos la carpeta template:  'DIRS': ['templates']
7. Levantamos el servidor y comprobamos que funciona: "python manage.py runserver".
8. Construmos los formularios, por convención en Django están aislados en su propia carpeta:
		- Creamos una carpeta nueva dentro de template llamada "forms"
		- Creamos dentro un html llamado contact que será donde crearemos el formulario
		- Lo incluimos en el html form : {% include 'forms/contact.html' %}
		- En el formulario escribirmos el método Post y la ruta, que la pondremos directamente en el urls.py, para una práctica limpia: 
			· En el urls.py: path('goal/', views.goal, name='goal')
			· En la views.py : 
				def goal(request):
    			return render(request, 'form.html', {})
			· En el contact.html: <form action="{% url 'goal' %}" method="GET">
	
	Ahora tenemos un formulario que, al pulsar en el botón enviar, enviará un nombre y un comentario a través del método get.
	Esta información será enviada a la url goal que recepcionaraá los datos en la request y trabajará los datos en su vista realizando las acciones necesarias.
	Posteriormente devolverá al usuario la respuesta correspondiente. Para ello creamos otra vista:
		- Creamos una vista nueva llamada success y su success.html dentro de la carpeta templates:
			def goal(request):
    		return render(request, 'success.html', {})

9. Comenzamos a trabajar la vista goal:

	1.- Primer ejemplo:

			def goal(request):

			if request.method == 'GET':
				return render(request, 'success.html', {})

			else:
				return HttpResponse("El método POST no está soportado para esta ruta")
	
	2.- Segundo ejemplo con una estructura de guarda (como usamos un return no vamos a necesitar el else):
			def goal(request):
				if request.method != 'GET':
					return HttpResponse("El método POST no está soportado para esta ruta")
				
				name = request.GET['name'] #Creamos una variable name, accedemos a get y, dentro de get accedemos al elemento name del formulario y se lo pasamos al contexto en nuestra vista.
				return render(request, 'success.html', {'name': name})
	
	3.- Hacemos uso de la variable en success.html:  <h1>Gracias por la información, {{name}}</h1>


32. FORMULARIO HTML: POST

Primero, reestructuramos las urls y le cambiamos el nombre:

 	path('get/form/', views.getform, name='form'),
    path('get/goal/', views.getgoal, name='goal')

También cambiamos la vista: getForm y getGoal, los nomres de las funciones

1. Creamos una estructura para poder visualizar el formulario escrito a través de post:

	1º.- Creamos el path: 
		path ('post/form/', views.postForm, name= 'postGoal'),
    	path ('post/goal/', views.postGoal, name= 'postGoal')
	
	2ª.- Declaramos las vistas: 

			def postForm(request):
    			return HttpResponse ("En construcción...")

			def postGoal(request):
    			return HttpResponse("En construcción...")
	
	3º.- Realizamos los templates:
		·Creamos un html para goal y otro para succes.
		·Creamos un html dentro de la carpeta forms que se llamará 'create.html'
	
	4º.- Comprobamos que todo va bien levantando el servidor.

	5º.- Definimos bien las funciones incorporando el método render para mejorar la visualización

2. Realizamos el formulario en POST, dentro del archivo create.html:

	· Creamos el formulario con una acción ({% url 'postGoal' %}) y un método (POST)
	· En la vista de postGoal indicamos el método que va a estar utilizando la url. Lo haremos a través de una estructura de guarda:

3. Al definir la vista como lo habíamos hecho con el método Get nos da el error Forbiden (403): Cross Site Request Forgery, or when Django’s CSRF mechanism has not been used correctly.
El profesor lo explica de la siguiente manera:

	El error que no se está referenciando es el error del ataque crossating o el error bfsrf:
	dentro de las niveles de seguridad no solo adaptados por Django sino por casi todos los las 
	estructuras y los patrones de arquitectura de MVC y MTV y al final por cada framework que 
	incorpora una seguridad básica dentro de su desarrollo necesita hacer una protección contra
	el robo de  sesiones.
	Para ello se utiliza la protección de csrf y se hace a través de un token que envía el sitio, 
	nuestro sitio a la petición del servidor para verificar que la información se está enviando 
	desde el formulario que se debe enviar.
	Tiene una implementación muy sencilla y es otra de las ventajas que tiene Django que tienen 
	este tipo de frameworks Y es que nos incorporan la seguridad y no solo nos la incorporan sino 
	que cuando estamos usándola nos van a forzar a trabajar con ella de tal forma que vamos a evitar
	muchos problemas futuros.
	Al final lo que estamos haciendo es enviar un token en cada uno de nuestras de nuestras solicitudes 
	que nos va a ayudar a autenticarnos y En definitiva va a ayudar a la parte de servidor de Django a 
	saber que la información está siendo enviada por efectivamente quién debe enviarla.
	Lo único que tenemos que hacer es incorporar un parámetro dentro de los elementos que vamos a estar 
	enviando que es el  {% csrf_token %} y esto simplemente lo podemos inyectar con cs rf toquen, así tal cual, 
	así nuestra plantilla ya va a hacer el envío y, gracias a dicho envío, vamos a Añadir esa capa de   
	seguridad necesaria en nuestro sistema.

33. FORMULARIOS A TRAVÉS DE CLASES

FORMULARIO DESDE LA CLASE FOR

1. Nuevo proyecto form_django
2. Generamos una url que vamos a gestionar a través de una vista que creamos (views.py)
3. En settings.py creamos unos templates para poder visualizar el renderizado de los formularios ( 'DIRS': ['templates'],) y creamos la carpeta tempates
4. En la carpeta 'templates' genera,mos un form.html y le damos una estructura básica
5. En views.py importamos render: from django.shortcuts import render para poder visualizar nuestra platilla
6. Hacemos la migración y levantamos el servidor
	
Hacemos el formulario a través de formularios de django a través de clase, definiendo qué tiene cada formulario, luego lo pasamos por contexto para que lo pinte.

1. Creamos una rchivo que se llame forms.py, que será donde definiremos las clases que serán los formularios.
2. Importamos la clase de formularios: from django import forms
3. Creamos una clase por cada formulario, en nuestro caso solo uno para crear comentarios:
	class CommentForm(forms.Form):
		name = forms.CharField(label="Escribe tu nombre")
		url = forms.URLField(label="Tu sitio web", required=False)
		comment = forms.CharField()
4. La vista tiene que renderizar el formulario, por lo que vamos a form.html para pintarlo:
	. En views importamos el comentario: from .forms import CommentForm
	· Creamos una variable a la que asignamos el CommentForm y lo pasamos al contexto para renderizar
			def form(request):
    			comment_form = Comment_form()
    			return render(request, 'form.html', {'comment_form': comment_form})
	· Por último, en forms.py añadimos: {{ comment_form }} para pintar el formulario.
5. Levantamos elservidor y el formulario está listo.

6. Podemos especificar si, en el momento en que estamos pintando el form, queremos que encerrar los campor en algun tipo de contenido. Por ejemplo:
	· {{ comment_form.as_p }}: en el formulario, cada campo se muestra en un línea distinta
	· {{ comment_form.as_table }}: se organiza el contenido como una tabla
Esto son solo cambios semánticos, no estéticos, pues estos se realizan con widgets.

7. Comprobamos que estamos recibiendo correctamente la información, para ello:
	· Generamos una ruta:  path('goal/', views.goal, name="goal") que recepcionará la información
	· En la plantilla el formulario enviará la información a la url:  <form action="{% url 'goal' %}">
	· Incluimos el method en el formulario, get o post
	· Definimos la vista goal:			
			def goal(request):
				if request.method != 'GET':
					return HttpResponse('Método no permitido')
				
				return HttpResponse("Recibido")

8. Dudas:
	· Cómo validar los datos de una forma eficiente
	· Cómo personalizar el contenido igal que con html
	· Personalizar las validaciones
	· Si tengo que realizar un CRUD sobre un modelo, la estrucutra de un modelo de python es muy similar, cómo generar un formulario sin tener que hacer una doble descripción.

9. Pasar valores inicales al formulario, por ejemplo, para actualizar valores:
	def form(request):
		comment_form = CommentForm({'name': 'Mari', 'url': 'https:// www.mariacedev.com', 'comment': 'Hola amigos'})
		return render(request, 'form.html', {'comment_form': comment_form})



34. WIDGET EN FORMULARIOS

Para aplicar estilo a los formularios

Continuamos en el proyecto form_django

1. Creamos un nuevo formulario en el forms.py:
	class ContactForm(forms.Form):
    	name = forms.CharField(label="Nombre", max_length=50)
    	email = forms.EmailField(label="Email", max_length=50)
    	message = forms.CharField(label="Mensaje")
2. Generamos una nueva url: path('widget/', views.widget, name="widget")
3. Definimos la vista:
		def widget(request):
    		return HttpResponse("Éxito") 

4. Definimos el formulario en la views:
	· Nos traemos el fomulario: from .forms import CommentForm, ContactForm
	· Lo pasmos a nuestra vista por contexto:
		def widget(request):
    		form = ContactForm()
    		return render(request, 'widget.html', {'form': form})

5. Creamos un nuevo template: widget.html y le damos una estructura básica

6. Le damos formato al formulario:
	· En el forms.py añadimos el valor 'widget' en los campos. Especificamos el input y los atributos:

	name = forms.CharField(label="Nombre", max_length=50, widget=forms.TextInput(attrs={'class': 'input'}))

	· Le damos estilo usando la clase 'input' (nombre puesto como ejemplo, podría llamarse de cualquier manera):

		<style>
			.input {
				background-color: blueviolet;
			}
   		</style>

	· Trabajamos con Bootstrap a modo de ejemplo:
		-Lo traemos al html:
			<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">

			<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.min.js" integrity="sha384-cuYeSxntonz0PPNlHhBs68uyIAVpIIOZZ5JqeqvYYIcEL727kskC66kF92t6Xl2V" crossorigin="anonymous"></script>

		- Le aplicamos una clase de Bootstrap a todos los campos desde el forms.py:

			class ContactForm(forms.Form):
				name = forms.CharField(label="Nombre", max_length=50, widget=forms.TextInput(attrs={'class': 'form-control'}))
				email = forms.EmailField(label="Email", max_length=50, widget=forms.EmailInput(attrs={'class': 'form-control'}))
				message = forms.CharField(label="Mensaje", widget=forms.Textarea(attrs={'class': 'form-control'}))

		- También podemos darle estilo en línea o con un css externo.

35. VALIDACIÓN DE FORMULARIOS

Debemos tener en cuenta 2 tipos de validaciones:
	· Validaciones generales: aquellas que están explícitas en el formato del dato que rellena el usuario (si el dato es ChardField y tiene un max_length lo que introduzca el usuario debe ajustarse a ello). Usamos los métodos que Django nos ofrece.
	· Validaciones personalizadas: Por ejemplo, solo aceptamos los email de la compañía. 

Utilizamos el formulario del anterior apartado.

1. Validaciones generales:

 -Incluimos en una misma vista el método get y post, lo hacemos en la vista widget.

 -Utilizamos esta vista para la gestión de los datos del post y trabajamos la validación:
	· Utilizamos el método isValid
		def widget(request):
			if request.method == 'GET':
				form = ContactForm()
				return render(request, 'widget.html', {'form': form})
			
			if request.method == 'POST':
				form = ContactForm(request.POST)
				if form.is_valid():
					#Todas las acciones cuando los datos son correctos
					return HttpResponse("Válido")
				else:
					#Comunicamos al usuario que los datos no son válidos
					return HttpResponse("No válido")

2. Validaciones personales:

Para ello usamos las funciones 'clean':

	def clean_name(self):
        name = self.cleaned_data.get("name") #Para que comience a partir de las validaciones generales
        #A partir de aquí comenzamos con las validaciones personalizadas

        if name != "Open":
            raise forms.ValidationError("Tan solo el valor Open está permitido para este campo")
        
        else:
            return name

Para mostrar en el template los errores al usuario:

if request.method == 'POST':
        form = ContactForm(request.POST)
        if form.is_valid():
            #Todas las acciones cuando los datos son correctos
            return HttpResponse("Válido")
        else:
            #Comunicamos al usuario que los datos no son válidos
            return render(request, 'widget.html', {'form': form})

36. FORMULARIOS A PARTIR DE MODELO

La manera en que se crean las clases en los formularios es muy similar a cómo se hacen en los modelos.
Por ello, para seguir los principios DRY (dont repeat yourself), existen los model form.

Creamos un nuevo proyecto con un model form:

1. django-admin startproject model_form
2. python manage.py startapp employees
3. settings.py>INSTALLED_APPS='employees'
4. python manage.py check employees
5. settings.py> 'DIRS': ['template']
6. employees>models.py:
	class Employees(models.Model):
		name = models.CharField(max_length=50, blank=False, null=False)
		last_name = models.CharField(max_length=50, blank=False, null=False)
		email = models.EmailField(max_length=50, blank=False, null=False)

		def __str__(self):
			return self.name
7. python manage.py makemigrations
8. python manage.py migrate
9. model_form>urls.py>path('', include('employees.urls'))
10. employees>urls.py> path('', views.index, name="index")
11. Creamos views.py en employees:
	def index(request):
    	return HttpResponse("Correcto")
12. Creamos carpeta template, con index.html y le damos una estructura
13. Devolvemos un render en la vista index:
	def index(request):
    	return render(request, 'index.html', {})

14. Hacemos un formulario para introducir empleados:
	· Creamos forms.py en employees
	· Importamos: from django.forms import ModelForm
	· Importamos el modelo Employee
	· Creamos una clase EmployeeForm(ModelForm)
	· Creamos una clase Meta para que Django conozca los campos empleado:
		class EmployeeForm(ModelForm):
			class Meta:
				model = Employee
	· En views.py importamos EmployeeForm: from .forms import EmployeeForm
	· Completamos la vista:
		def index(request):
			form = EmployeeForm()
			return render(request, 'index.html', {'form': form})
	· Introducimos los campos que vamos a usar en forms.py:
		class EmployeeForm(ModelForm): #Quiero un formulario
			class Meta:
				model = Employee #Que rellene este modelo
				fields = ['name', 'last_name', 'email']#Con estos campos
	· Comprobamos que funciona
	· Completamos el html pasándole el form de la vista:
		<form action="" method="post">
			{% csrf_token %}
			{{ form }}
			<input type="submit" value="Crear">
    	</form>
	·Atajo para introducir todos los campos del modelo:
		fields = '__all__'
	· Añadir campos:
		extra_fields = ['salary']
	· Excluir campos:
		exclude = ('email, )

	














		











