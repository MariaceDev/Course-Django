
NUEVO PROYECTO
django-admin startproject holamundo

Crea un archivo manage.py y una carpeta holamundo, que una aplicación que se gestiona como un paquete.
El directorio raíz que se crea como defecto tiene el mismo nombre que el proyecto.

manage.py nos permite gestionar el proyecto, no hay qie tocar, se encarga de poner a nuestgra disposición las instrucciones de consola para poder operar.

En la carpeta está toda la estructura de archivos: todas las aplicaciones (carpetas) tienen:
- un _init_.py, para poder gestionar cada aplicaicón com unnpaquete
- asgi.py y wsgi son archivos auxiliares, que nos van a servir para ayudarnos por ejemplo, con el servidor y otras acciones ausiliares.
- urls.py: asocia las urls con las vistas que los gestionan. Es un array con los path. Aquí escribiremos todas las rutas y las vistas, también  los templates.
- settings.py: para establecer las configuraciones del paquete. Por ejemplo: hay un array con las apps instaladas, gracias a que es un framework vienen ya instaladas

1.5 PRIMER HOLA MUNDO: CIRCUITO COMPLETO

- Creamos una archivo de vistas para controlar la ruta y devolver un mensaje http para poder comprobar el circuito completo de esta arquitectura.
- Entramos en la terminal y creamos la estructura de base de 11:32 03/07/2023datos:para ello migra los modelos de datos a nuestro sistema de permanencia de datos a través del comando "migrator". Lo tendremos que hcer cada vez que modifiquemos la estructura de datos, al inicio y cada vez que trabajemos con él.
- Primero debemos llamar al archivo manage.py para hacer cualquier acción en la terminal y luego le solicitamos el comando ejecutar
- Entonces ejecutamos el comando: python manage.py migrate (tienes que colocarte en la ruta correcta)
- Para ver la db en vs instalamos sql tools y sql viewer
- Para continuar, podemos usar el servidor de django llamando desde el terminal: python manage.py runserver
- Entonces nos levanta un servidor en el puerto 8000, si seguimos el link veremos la página de django
- Para interrumpir el servidor usamos "cntrl c".
- Necesitamos un archivo de vistas, recordamos: las url apuntan a las vistas y estas trabajan con los modelos y estos devuelven los template.
- Entonces creamos un views.py que es donde vamos a declarar las vistas con las que estamos trabajando.
- Las vistas contienen la lógica y solo son diferentes funciones a las que se asociaran las url.
- Creamos la primera vista: 
#las vistas siempre van a tener un parámetro que es el request, la petición de ejecutar esta vista
#En este ejemplo nos saltamos los modelos y las plantillas con las que trabajaremos más adelente

from django.http import HttpResponse

def saludo(request):
    return HttpResponse("Hola mundo")

# Ya tenemos la vista creada, ahora necesitamos asociar una ruta que ejecute la vista. 
# Para ello nos vamos el urls.py y la definimos: path('saludo/', views.saludo, name='saludo') #es muy imprtante terminar con "/"
 Además, tenemos que importar la views: from . import views

- Levantamos de nuevo el servidor y seguimos el link. Aparece de inicio un error y es normal, porque no tenemos ninguna ruta en la raiz del proyecto.
- Las que exiten son admin y saludo. entonces ejecutamos la ruta saludo en la barra del navegador añadiendo: /saludo
- YA TENEMOS NUESTRO PRIMER CIRCUITO

2.1 RUTAS CON PARÁMETROS

Esto nos permitirá recepcionar variables a través de la url que puede posteriormente utilizar en nuestra vista.

- Hasta ahora solo hemos definido rutas estáticas, no reciben ninguan información a través de la url.
- si hacemos un blog, por ejemplo, y queremos recibir el id de la noticia: path("post/3") o una función para pedir la edad path("adulto/edad")
path('adulto/<int:edad>/<int:altura>/'): asi se introducen las variables. después lo asociamos a na vista:  path('adulto/<int:edad>/<int:altura>/' views.adulto, name='adulto')

- Hacemos una prueba:

path('adulto/<int:edad>/', views.adulto, name='adulto')

def adulto (request, edad):
    if(edad >= 18):
        return HttpResponse ("Es mayor de edad.")
    else:
        return HttpResponse ("No eres mayor de edad.")



http://127.0.0.1:8000/adulto/14/
No eres mayor de edad.


2.2 USO DE PLANTILLAS

Qué son las plantillas y configuramos nuestro primer template.

Creamos un nuevo proyecto: django-admin startproject plantillas

1º.- Migramos toda la estructura: python manage.py migrate.
2º.- Levantamos servidor: python manage.py runserver.
3º.- Creamos un views.py 
4ª.- Creamos un path: path('simple', views.simple, name='simple') e importamos el views.py
5º.- Creamos una vista nueva, pero en vez de devolver un http, ddevolvemos un template que muestre la información al usuario

Los template o plantillas es un trozo de texto que aislamos dentro de un archivo, que, de forma habitual será HTML. 
Las plantillas contienen la parte visual de proyecto, la lógica estará en las views.
Carga de un template:
1- Establecer el directorio donde vamos a colocar las plantillas, que será en: settings.py
Ahí hay un array de direcciones para buscar donde se encuentran la plantillas:  'DIRS': ['templates']
2- Creamos en la raíz una carpeta con el mismo nombre.
3- Cremos un archivo para views que se va a llamar simple.html, donde podemos escribir nuestro código html
4- Volvemos al archivo views para terminar el return, que debe devolver la plantilla. Hay diferentes métodos, como haciendo la carga de un archivo.
Pero django nos facilita con atajos a través del método render: from django.shortcuts import render
Después terminamos la vista usando render al que le pasamos tres parámetros: el request o petición, la ruta hacia el html y el contexto, que es un diccionario, se lo pasamos vacío porque esta plantilla no necesita nada para funcionar):

def simple(request):
    return render(request, 'simple.html', {})

2.3. USO DE CONTEXTOS

1.- Hacemos un nuevo path al que llamamos dinámico.
2.- Definimos la vista en views con una función. Para ello hacemos uso de una variable pasada por paramertro. Para en el path solicitamos un string llamado nombre:
 
	path('dinamico/<str:name>/', views.dinamico, name='dinamico')

3.- Creamos un nuevo archivo HTML llamado dinamico, utilizando la plantilla que hemos creado.
4.- Para la vista, utilizamos un return con render al que le pasamos los tres parámetros definidos en el apartado anterior, con la diferencia de que, en vez de pasar un diccionario vacío, le pasamos una variable llamada contexto que contendrá el diccionario.

	def dinamico (request, name):
    	  context = {'name': name}
    	  return render(request, 'dinamico.html', context)

5.- En el contexto lo que hacemos es el uso de un par clave:valor, lo que hacemos es uso de la clave para que pinte el valor. Para ello, en HTML lo que hacemos es una doble llave para colocar el name. Así, colocamos el valor del contexto, hacienod uso de la información contextual:
	
	    <h1>Hola {{name}}</h1>

6.- Podemos pasar todo tipo de datos, incluso objetos y clases con sus métodos. No solo tipo de datos primitivos.
7.- Porbamos a pasar un array:

	def dinamico (request, name):
    	  categories = ['code', 'design', 'marketing']
    	  context = {'name': name, 'categories': categories}
    	  return render(request, 'dinamico.html', context)
         ____________________________________________________

  	<body>
          <h1>Hola {{name}}</h1>
          <h3>Categorías</h3>
          <p>{{categories}}</p>   
    	</body>

Resultado:

Hola Mari Carmen
Categorías
['code', 'design', 'marketing']

Como podemos ver, nos pinta la estructura, pero lo que queremos es simplemente acceder a la imformación de la estructura, para ello tendremos que recorrer la estructura para pintar la info sin corchetes, de forma correcta.


2.4. BUCLES Y CONDICIONALES EN PLANTILLAS

Es importante que no cargemos acciones de lógica en las plantillas (HTML), igualmente no debemos pintar (visualización) en las vistas.

Para recorrer las estructuras, BUCLES, debemos usar una nomenclatura diferente {% %}. La estructura quedaría de la siguiente manera:

   <body>
        <h1>Hola {{name}}</h1>
        <h3>Categorías</h3>
        <ul>
            {% for category in categories %} <!--Hacemos un foreach para recorrer el array-->
                <li>{{category}}</li> <!--Escribimos código con la imformación que usamos, es un literal-->
            {% endfor%} <!--Cerramos el foreach-->
        </ul>  
    </body>

Y el resultado:

Hola Mari Carmen
Categorías
   · code
   · design
   · marketing

También, podemos incorporar CONDICIONALES:

   <body>
        <h1>Hola {{name}}</h1>
        <h3>Categorías</h3>
        <ul>
            {% for category in categories %} <!--Hacemos un foreach para recorrer el array-->
                {% if category == 'code' %} <!--Incorporamos el if con la condición-->
                    <li><b>{{category}}</b></li> <!--Le indicamos que lo pinte en negrita-->
                {% else %} <!--Si no se cumple la condición: -->
                    <li>{{category}}</li> <!--Escribimos código con la imformación que usamos, es un literal-->
                    {% endif %} <!--Cerramos el if-->
            {% endfor %} <!--Cerramos el foreach-->
        </ul>  
    </body>


2.5. COMENTARIOS Y FILTROS

En las plantillas podemos escribir COMENTARIOS que no van a ser pintados en la consola: <!---->, aparece en la consola de Google cuando inspeccionamos el código.

Hay dos formas:

-Comentario simple: {# #}
- Comentario multilinea: {% coment %}
                          Hola, soy comentario multilínea
                         {% endcoment %}



Django ofrece una gran cantidad de filtros para realizar especificaciones. Por ejemplo, finaliza el bucle y queremos colocar un h5 con el total de categorías, aunque no tengamos el length, podemos usar un filtro:
	
	<h5>Total de categorías: {{categories|length}}</h5>

Y el resultado sería:

Hola Mari Carmen
Categorías
   · code
   · design
   · marketing

Total de categorías: 3

Otro ejemplo, que lo coloque en mayúsculas:

	<li><b>{{category | upper}}</b></li>

También se pueden anidar

	<li><b>{{category | upper | lower | capitalize | title }}</b></li>


2.6. ARCHIVOS ESTÁTICOS

1.- Creamos un nuevo proyecto: django-admin startproject estaticos
2.- Migramos el sistema: python manage.py migrate
3.- Corremos el servidor: python manage.py runserver
4.- Generamos un circuito para caragr una plantilla:

	1. setting.py e indicamos el directorio 'templates'
	2. Creamos el directorio 'templates'
	3. Accedemos al archivo de rutas y cargamos una vista
		1. Para ello generamos el archivo de vistas: views.py
		2. Creamos una vista llamada estaticos que, por ahora, dejamos vacía:
			def estaticos(request):
    				return ""
	4. Colocamos en la urls la importación de dicho archivo:
		from . import views
		path('estaticos/', views.estaticos, name='estaticos')
	5. El archivo views.py importamos el método render para poder pintar las vistas:
		from django.shortcuts import render
		def estaticos(request):
    			return render (request, 'estaticos.html', {})
	6. Creamos la plantilla: estaticos.html


 ¿Cómo hacemos la importación de archivos estáticos en una plantilla?

1. Vamos al archivo setting.py y en STATIC_URL = 'static/' es la ubicación donde pondremos los archivos estáticos.
Por defecto se coloca en la raíz del proyecto. Nosotros lo haremos así:
	- Accedemos a nuestro proyecto y creamos un directorio donde irán todos los archivos js, css, imágenes, etc., que usaremos en el proyecto.

2. Creamos el archivo estático dentro de la carpeta, como por ejemplo un css: style.css
3. Indicamos a la plantilla, antes que el doctype, que va a hacer uso de elementos estáticos: {% load static %}
4. Para cargar el css en el HTML no se hace de la manera normal, sino utilizando la nomenclatura de django que va a especificar dentro de l aplantilla qué archivos van a ser de carga estática:
	  <link rel="stylesheet" type="text/css" href="{% static 'style.css' %}" >
5. Comprobamos el navegador y no se ha caragdo correctamente debido a la configuración, porque tenemos que indicar los directorios que va a tener la configuración sobre los archivos estáticos.
Esto se hace añadiendo una variable de entorno más en el setting. La variable es:
	STATICFILES_DIRS = [#recibe un array con las url que vamos a tener
	BASE_DIR / 'static', #añadimos el directorio base junto con static, que es lo que hemos definido anteriormente
	'/var/www/static', #añadimos este directorio, que será el que albergará los archivos estáticos una vez hagamos el deploy, aunque todavía no esté creada
	]

2.7. HERENCIA DE PLANTILLAS

Nos va apermitir modularizar nuestro HTML y evitar la reutilización de código, para no concurrir en duplicidad de etiquetas o módulos.
Creamos un nuevo proyecto con la views, la carpeta template, static y todo el recorrido para cargar una plantilla y el contenido estático que necesite.

Añadimos una nueva ruta, porque nuestro proyecto puede necesitar varias rutas:
	path('ejemplo/', views.ejemplo, name='ejemplo'),
Y le creamos una vista:
	def ejemplo (request):
    return render (request, 'ejemplo.html', {})
Y otra ruta más para que se entienda bien, con su vista y su template, a la que llamaremos 'otra'.

Para rellenar los template ejemplo u otra, estamos copiando contenido y rellenando. Esto no es una buena práctica, es un problema.
Para evitarlo, tenemos las herencias. Indicamos que una plantilla va a heredar de una plantilla padre que le puede heredar una estructura.
 así estandarizamos el contenido del layout.

Para hacerlo, creamos un nuevo directorio, dentro de template, que se llama de diferentes maneras ( app, base o layout) y dentro creamos una plantilla: base.html.
Rellenamos la platilla con las etiquetas básicas y le añadimos un archivo css.

Ahora el siguiente paso es extender el contenido de la base a las otras plantillas. Para ello especificaremos qué partes pueden ser extendidas, es decir, las que van a cambiar por medio de bloques:
	{% block styles %}{% endblock %} -Para incluir más hojas de estilo
	{% block title %}{% endblock %} -Para cambiar el título
	{% block content %}{% endblock %} -PAra cambiar contenido
	{% block scripts %}{% endblock %} - Para incluir diferentes scripts

El siguiente paso será cómo pueden el resto de plantillas extender la información de la base:
	{% extends './layout/base.html' %}
Ahora, por defecto, tendrán todo el contenido de la base, que se mostrará en herencia.

Y para extender el contenido que queremos cambiar bastaría con definirlo:
	{% block title %}HERENCIA{% endblock %}

	{% block content %}
   	 <h1> HERENCIA</h1>
	{% endblock %}

2.8. ENLACE E INCLUSIÓN

Primero creamos un path para incluir el directorio raíz ddel proyectos:
	 path('index/', views.index, name='index')
Y definimos la vista:
	def index (request):
    		return render (request, 'index.html', {}) 
Creamos el archivo index.html dentro de la carpeta template y extendemos la plantilla base.

Empezamos con los links, haciendo las vinculaciones a través de los links y no escribiéndolo sobre la barra de direcciones.
Para ello, vamos al base.html y definimos ahí los enlaces. 
Para hacer los enlaces utilizamos los nombres definidos en el path, también la ruta del path, aunque es un codigo más difícil de mantener si hubiera que modificarlo.
El nombre es mucho más fácil de modificar porque solo habría que cambiarlo una vez:

	 <li><a href="{% url 'herencia' %}">Herencia</a></li>

Para modularizar mucho más el código podemos hacer uso de los includes. Dentro de layouts hacemos una nueva carpeta llamada 'parcials' y dentro creamos una plantilla que sea un menú html.

Cortamos el nav del archivo de la base y lo pegamos en el menu.html.
Ahora o que queremos es que la base extienda el menú con el include:

	  {% include 'layouts/partials/menu.html' %}

2.9. DOCUMENTACIÓN OFICIAL

2.10. PRÁCTICA DE PLANTILLAS






