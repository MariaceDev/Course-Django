
NUEVO PROYECTO
django-admin startproject holamundo

Crea un archivo manage.py y una carpeta holamundo, que una aplicación que se gestiona como un paquete.
El directorio raíz que se crea como defecto tiene el mismo nombre que el proyecto.

manage.py nos permite gestionar el proyecto, no hay qie tocar, se encarga de poner a nuestgra disposición las instrucciones de consola para poder operar.

En la carpeta está toda la estructura de archivos: todas las aplicaciones (carpetas) tienen:
- un _init_.py, para poder gestionar cada aplicaicón com unnpaquete
- asgi.py y wsgi son archivos auxiliares, que nos van a servir para ayudarnos por ejemplo, con el servidor y otras acciones ausiliares.
- urls.py: asocia las urls con las vistas que los gestionan. Es un array con los path. Aquí escribiremos todas las rutas y las vistas, también  los templates.
- settings.py: para establecer las configuraciones del paquete. Por ejemplo: hay un array con las apps instaladas, gracias a que es un framework vienen ya instaladas

1.5 PRIMER HOLA MUNDO: CIRCUITO COMPLETO

- Creamos una archivo de vistas para controlar la ruta y devolver un mensaje http para poder comprobar el circuito completo de esta arquitectura.
- Entramos en la terminal y creamos la estructura de base de 11:32 03/07/2023datos:para ello migra los modelos de datos a nuestro sistema de permanencia de datos a través del comando "migrator". Lo tendremos que hcer cada vez que modifiquemos la estructura de datos, al inicio y cada vez que trabajemos con él.
- Primero debemos llamar al archivo manage.py para hacer cualquier acción en la terminal y luego le solicitamos el comando ejecutar
- Entonces ejecutamos el comando: python manage.py migrate (tienes que colocarte en la ruta correcta)
- Para ver la db en vs instalamos sql tools y sql viewer
- Para continuar, podemos usar el servidor de django llamando desde el terminal: python manage.py runserver
- Entonces nos levanta un servidor en el puerto 8000, si seguimos el link veremos la página de django
- Para interrumpir el servidor usamos "cntrl c".
- Necesitamos un archivo de vistas, recordamos: las url apuntan a las vistas y estas trabajan con los modelos y estos devuelven los template.
- Entonces creamos un views.py que es donde vamos a declarar las vistas con las que estamos trabajando.
- Las vistas contienen la lógica y solo son diferentes funciones a las que se asociaran las url.
- Creamos la primera vista: 
#las vistas siempre van a tener un parámetro que es el request, la petición de ejecutar esta vista
#En este ejemplo nos saltamos los modelos y las plantillas con las que trabajaremos más adelente

from django.http import HttpResponse

def saludo(request):
    return HttpResponse("Hola mundo")

# Ya tenemos la vista creada, ahora necesitamos asociar una ruta que ejecute la vista. 
# Para ello nos vamos el urls.py y la definimos: path('saludo/', views.saludo, name='saludo') #es muy imprtante terminar con "/"
 Además, tenemos que importar la views: from . import views

- Levantamos de nuevo el servidor y seguimos el link. Aparece de inicio un error y es normal, porque no tenemos ninguna ruta en la raiz del proyecto.
- Las que exiten son admin y saludo. entonces ejecutamos la ruta saludo en la barra del navegador añadiendo: /saludo
- YA TENEMOS NUESTRO PRIMER CIRCUITO

2.1 RUTAS CON PARÁMETROS

Esto nos permitirá recepcionar variables a través de la url que puede posteriormente utilizar en nuestra vista.

- Hasta ahora solo hemos definido rutas estáticas, no reciben ninguan información a través de la url.
- si hacemos un blog, por ejemplo, y queremos recibir el id de la noticia: path("post/3") o una función para pedir la edad path("adulto/edad")
path('adulto/<int:edad>/<int:altura>/'): asi se introducen las variables. después lo asociamos a na vista:  path('adulto/<int:edad>/<int:altura>/' views.adulto, name='adulto')

- Hacemos una prueba:

path('adulto/<int:edad>/', views.adulto, name='adulto')

def adulto (request, edad):
    if(edad >= 18):
        return HttpResponse ("Es mayor de edad.")
    else:
        return HttpResponse ("No eres mayor de edad.")



http://127.0.0.1:8000/adulto/14/
No eres mayor de edad.


2.2 USO DE PLANTILLAS

Qué son las plantillas y configuramos nuestro primer template.

Creamos un nuevo proyecto: django-admin startproject plantillas

1º.- Migramos toda la estructura: python manage.py migrate.
2º.- Levantamos servidor: python manage.py runserver.
3º.- Creamos un views.py 
4ª.- Creamos un path: path('simple', views.simple, name='simple') e importamos el views.py
5º.- Creamos una vista nueva, pero en vez de devolver un http, ddevolvemos un template que muestre la información al usuario

Los template o plantillas es un trozo de texto que aislamos dentro de un archivo, que, de forma habitual será HTML. 
Las plantillas contienen la parte visual de proyecto, la lógica estará en las views.
Carga de un template:
1- Establecer el directorio donde vamos a colocar las plantillas, que será en: settings.py
Ahí hay un array de direcciones para buscar donde se encuentran la plantillas:  'DIRS': ['templates']
2- Creamos en la raíz una carpeta con el mismo nombre.
3- Cremos un archivo para views que se va a llamar simple.html, donde podemos escribir nuestro código html
4- Volvemos al archivo views para terminar el return, que debe devolver la plantilla. Hay diferentes métodos, como haciendo la carga de un archivo.
Pero django nos facilita con atajos a través del método render: from django.shortcuts import render
Después terminamos la vista usando render al que le pasamos tres parámetros: el request o petición, la ruta hacia el html y el contexto, que es un diccionario, se lo pasamos vacío porque esta plantilla no necesita nada para funcionar):

def simple(request):
    return render(request, 'simple.html', {})

2.3. USO DE CONTEXTOS

1.- Hacemos un nuevo path al que llamamos dinámico.
2.- Definimos la vista en views con una función. Para ello hacemos uso de una variable pasada por paramertro. Para en el path solicitamos un string llamado nombre:
 
	path('dinamico/<str:name>/', views.dinamico, name='dinamico')

3.- Creamos un nuevo archivo HTML llamado dinamico, utilizando la plantilla que hemos creado.
4.- Para la vista, utilizamos un return con render al que le pasamos los tres parámetros definidos en el apartado anterior, con la diferencia de que, en vez de pasar un diccionario vacío, le pasamos una variable llamada contexto que contendrá el diccionario.

	def dinamico (request, name):
    	  context = {'name': name}
    	  return render(request, 'dinamico.html', context)

5.- En el contexto lo que hacemos es el uso de un par clave:valor, lo que hacemos es uso de la clave para que pinte el valor. Para ello, en HTML lo que hacemos es una doble llave para colocar el name. Así, colocamos el valor del contexto, hacienod uso de la información contextual:
	
	    <h1>Hola {{name}}</h1>

6.- Podemos pasar todo tipo de datos, incluso objetos y clases con sus métodos. No solo tipo de datos primitivos.
7.- Porbamos a pasar un array:

	def dinamico (request, name):
    	  categories = ['code', 'design', 'marketing']
    	  context = {'name': name, 'categories': categories}
    	  return render(request, 'dinamico.html', context)
         ____________________________________________________

  	<body>
          <h1>Hola {{name}}</h1>
          <h3>Categorías</h3>
          <p>{{categories}}</p>   
    	</body>

Resultado:

Hola Mari Carmen
Categorías
['code', 'design', 'marketing']

Como podemos ver, nos pinta la estructura, pero lo que queremos es simplemente acceder a la imformación de la estructura, para ello tendremos que recorrer la estructura para pintar la info sin corchetes, de forma correcta.


2.4. BUCLES Y CONDICIONALES EN PLANTILLAS

Es importante que no cargemos acciones de lógica en las plantillas (HTML), igualmente no debemos pintar (visualización) en las vistas.

Para recorrer las estructuras, BUCLES, debemos usar una nomenclatura diferente {% %}. La estructura quedaría de la siguiente manera:

   <body>
        <h1>Hola {{name}}</h1>
        <h3>Categorías</h3>
        <ul>
            {% for category in categories %} <!--Hacemos un foreach para recorrer el array-->
                <li>{{category}}</li> <!--Escribimos código con la imformación que usamos, es un literal-->
            {% endfor%} <!--Cerramos el foreach-->
        </ul>  
    </body>

Y el resultado:

Hola Mari Carmen
Categorías
   · code
   · design
   · marketing

También, podemos incorporar CONDICIONALES:

   <body>
        <h1>Hola {{name}}</h1>
        <h3>Categorías</h3>
        <ul>
            {% for category in categories %} <!--Hacemos un foreach para recorrer el array-->
                {% if category == 'code' %} <!--Incorporamos el if con la condición-->
                    <li><b>{{category}}</b></li> <!--Le indicamos que lo pinte en negrita-->
                {% else %} <!--Si no se cumple la condición: -->
                    <li>{{category}}</li> <!--Escribimos código con la imformación que usamos, es un literal-->
                    {% endif %} <!--Cerramos el if-->
            {% endfor %} <!--Cerramos el foreach-->
        </ul>  
    </body>


2.5. COMENTARIOS Y FILTROS

En las plantillas podemos escribir COMENTARIOS que no van a ser pintados en la consola: <!---->, aparece en la consola de Google cuando inspeccionamos el código.

Hay dos formas:

-Comentario simple: {# #}
- Comentario multilinea: {% coment %}
                          Hola, soy comentario multilínea
                         {% endcoment %}



Django ofrece una gran cantidad de filtros para realizar especificaciones. Por ejemplo, finaliza el bucle y queremos colocar un h5 con el total de categorías, aunque no tengamos el length, podemos usar un filtro:
	
	<h5>Total de categorías: {{categories|length}}</h5>

Y el resultado sería:

Hola Mari Carmen
Categorías
   · code
   · design
   · marketing

Total de categorías: 3

Otro ejemplo, que lo coloque en mayúsculas:

	<li><b>{{category | upper}}</b></li>

También se pueden anidar

	<li><b>{{category | upper | lower | capitalize | title }}</b></li>


2.6. ARCHIVOS ESTÁTICOS

1.- Creamos un nuevo proyecto: django-admin startproject estaticos
2.- Migramos el sistema: python manage.py migrate
3.- Corremos el servidor: python manage.py runserver
4.- Generamos un circuito para caragr una plantilla:

	1. setting.py e indicamos el directorio 'templates'
	2. Creamos el directorio 'templates'
	3. Accedemos al archivo de rutas y cargamos una vista
		1. Para ello generamos el archivo de vistas: views.py
		2. Creamos una vista llamada estaticos que, por ahora, dejamos vacía:
			def estaticos(request):
    				return ""
	4. Colocamos en la urls la importación de dicho archivo:
		from . import views
		path('estaticos/', views.estaticos, name='estaticos')
	5. El archivo views.py importamos el método render para poder pintar las vistas:
		from django.shortcuts import render
		def estaticos(request):
    			return render (request, 'estaticos.html', {})
	6. Creamos la plantilla: estaticos.html


 ¿Cómo hacemos la importación de archivos estáticos en una plantilla?

1. Vamos al archivo setting.py y en STATIC_URL = 'static/' es la ubicación donde pondremos los archivos estáticos.
Por defecto se coloca en la raíz del proyecto. Nosotros lo haremos así:
	- Accedemos a nuestro proyecto y creamos un directorio donde irán todos los archivos js, css, imágenes, etc., que usaremos en el proyecto.

2. Creamos el archivo estático dentro de la carpeta, como por ejemplo un css: style.css
3. Indicamos a la plantilla, antes que el doctype, que va a hacer uso de elementos estáticos: 
		{% load static %}
4. Para cargar el css en el HTML no se hace de la manera normal, sino utilizando la nomenclatura de django que va a especificar dentro de l aplantilla qué archivos van a ser de carga estática:
	  <link rel="stylesheet" type="text/css" href="{% static 'style.css' %}" >
5. Comprobamos el navegador y no se ha caragdo correctamente debido a la configuración, porque tenemos que indicar los directorios que va a tener la configuración sobre los archivos estáticos.
Esto se hace añadiendo una variable de entorno más en el setting. La variable es:
	STATICFILES_DIRS = [#recibe un array con las url que vamos a tener
	BASE_DIR / 'static', #añadimos el directorio base junto con static, que es lo que hemos definido anteriormente
	'/var/www/static', #añadimos este directorio, que será el que albergará los archivos estáticos una vez hagamos el deploy, aunque todavía no esté creada
	]

2.7. HERENCIA DE PLANTILLAS

Nos va apermitir modularizar nuestro HTML y evitar la reutilización de código, para no concurrir en duplicidad de etiquetas o módulos.
Creamos un nuevo proyecto con la views, la carpeta template, static y todo el recorrido para cargar una plantilla y el contenido estático que necesite.

Añadimos una nueva ruta, porque nuestro proyecto puede necesitar varias rutas:
	path('ejemplo/', views.ejemplo, name='ejemplo'),
Y le creamos una vista:
	def ejemplo (request):
    return render (request, 'ejemplo.html', {})
Y otra ruta más para que se entienda bien, con su vista y su template, a la que llamaremos 'otra'.

Para rellenar los template ejemplo u otra, estamos copiando contenido y rellenando. Esto no es una buena práctica, es un problema.
Para evitarlo, tenemos las herencias. Indicamos que una plantilla va a heredar de una plantilla padre que le puede heredar una estructura.
 así estandarizamos el contenido del layout.

Para hacerlo, creamos un nuevo directorio, dentro de template, que se llama de diferentes maneras ( app, base o layout) y dentro creamos una plantilla: base.html.
Rellenamos la platilla con las etiquetas básicas y le añadimos un archivo css.

Ahora el siguiente paso es extender el contenido de la base a las otras plantillas. Para ello especificaremos qué partes pueden ser extendidas, es decir, las que van a cambiar por medio de bloques:
	{% block styles %}{% endblock %} -Para incluir más hojas de estilo
	{% block title %}{% endblock %} -Para cambiar el título
	{% block content %}{% endblock %} -PAra cambiar contenido
	{% block scripts %}{% endblock %} - Para incluir diferentes scripts

El siguiente paso será cómo pueden el resto de plantillas extender la información de la base:
	{% extends './layout/base.html' %}
Ahora, por defecto, tendrán todo el contenido de la base, que se mostrará en herencia.

Y para extender el contenido que queremos cambiar bastaría con definirlo:
	{% block title %}HERENCIA{% endblock %}

	{% block content %}
   	 <h1> HERENCIA</h1>
	{% endblock %}

2.8. ENLACE E INCLUSIÓN

Primero creamos un path para incluir el directorio raíz ddel proyectos:
	 path('index/', views.index, name='index')
Y definimos la vista:
	def index (request):
    		return render (request, 'index.html', {}) 
Creamos el archivo index.html dentro de la carpeta template y extendemos la plantilla base.

Empezamos con los links, haciendo las vinculaciones a través de los links y no escribiéndolo sobre la barra de direcciones.
Para ello, vamos al base.html y definimos ahí los enlaces. 
Para hacer los enlaces utilizamos los nombres definidos en el path, también la ruta del path, aunque es un codigo más difícil de mantener si hubiera que modificarlo.
El nombre es mucho más fácil de modificar porque solo habría que cambiarlo una vez:

	 <li><a href="{% url 'herencia' %}">Herencia</a></li>

Para modularizar mucho más el código podemos hacer uso de los includes. Dentro de layouts hacemos una nueva carpeta llamada 'parcials' y dentro creamos una plantilla que sea un menú html.

Cortamos el nav del archivo de la base y lo pegamos en el menu.html.
Ahora o que queremos es que la base extienda el menú con el include:

	  {% include 'layouts/partials/menu.html' %}

2.9. DOCUMENTACIÓN OFICIAL

2.10. PRÁCTICA DE PLANTILLAS

________________________________________________________________________________________________________________
________________________________________________________________________________________________________________


3.1. MODULARIZACIÓN

Creamos la primera aplicación dentro de un proyecto ya creado en Django:

1. django-admin startproject modularizacion
2. creamos una nueva aplicación: 
	python manage.py startapp comentarios #el último es el nombre que hemos elegido para la app
3. la app funciona como otra aplicación y contiene otros archivos como el views, otro para test, para modularición, todos los iremos trabajando
4. contiene un directorio de migraciones.
5. Si queremos reutilizar la app de comentarios en nuestro proyecto práctica plantillas, tan solo tenemos que llevarnos el directorio al proyecto.
6. Tenemos que decirle a django cuáles de las aplicaciones que tenemos van a estar instaladas en el proyecto, es decir, cuáles son las que vamos a utilizar.
Esto lo hacemos en el archivo:
		 settings.py => INSTALLED_APPS => 'comentarios',
Como habita en la raíz del proyecto es suficiente con poner el nombre de la app. Como comentarios funciona como un paquete, se instala.

Para comprobar si la app está correctamente instalada ejecutamos en consola:
	python manage.py check comentarios
Respuesta: System check identified no issues (0 silenced).
Significa que ha detectado la app y no hay fallos en ella.

RESUMEN RECORRIDO ARQUITECTURA

1. El USUARIO realiza una petición a una URL que nosotros gestionamos con el archivo urls.py
2. Este urls.py deriba a una VIEWS.py que contendrá la lógica a través de funciones def.
3. El views.py puede que necesite realizar acciones con los datos del proyecto, esto lo hace a través de los MODELOS.
4. Los modelos a través del ORM harán las gestiones con el motor de base de datos para garantizar la persistencia.
5. Devuelve las informaciones a la VISTA, que renderiza, pinta un TEMPLATE, que es la información que recibe el usuario, la WEB servida en su navegador

Este patrón de arquitectura MODEL TEMPLATE VIEW (MTV) es una variación del (MVC). Las principales diferencias son:

	- En el patrón MVC, la Vista se encarga de la presentación de los datos al usuario, mientras que en el patrón MTV, 
	  la Plantilla se encarga de esta responsabilidad.
	- En el patrón MVC, el Controlador es responsable de recibir las acciones del usuario y actualizar el Modelo y la Vista en consecuencia. 
	- En el patrón MTV, la Vista se encarga de la lógica de negocio y la interacción entre el Modelo y la Plantilla.

3.2. MODELADO DE DATOS

Los modelos van a ser elementos que van a estar representando datos que el ORM se va a encargar de gestionar dentro de nuestro sistema de bases de datos.
El ORM de Django nos va a abstraer del ORM, por ejemplo consultas sql, etc. Podremos trabajar cada uno de los elementos como si fuese un objeto: en lugar de crear
tablas, crearemos clases en python. Estas clases extenderán un modelo y van a perminirnos crear objetos. El ORM de Django lo que hará por detrás es generar una tabla
en nuestro sistema de permanencia de datos por cada clase que creemos. Nosotros solo creamos clases y django una tabla, donce cada atributo corresponderá una tabla.


Comenzmos por el ejemplo más sencillo: un comentarios.

Trabjanmos con MODELS: cada modelo es una clase y empezamos por una:

	class comments (models.Model):

   		 def __str__(self):
      		  return

Cuando migremos esto, django detectará la clase comments y creará una tabla en la DB.
Ejemplo:

	class comments (models.Model):

    		name = models.CharField(max_length=255, null=False)
    		score = models.IntegerField(default=3)
    		comment = models.TextField(max_length=1000, null=True)

    		def __str__(self):
        		return self.name

Como hemos hecho una modificación del modelo, debemos hacer una migración. En Django se hace de la siguiente manera:

1. Pedimos que la clase sea traducida a sql:
	python manage.py makemigrations
Entonces nos crea este archivo:  comentarios\migrations\0001_initial.py

2. Ejecutamos la migración con: python manage.py migrate
Si vemos la DB, aparece la estructura habitual más una tabla llamada comentarios_comments (nombre_app.nombre_clase)
Si pulsamos vemos la tabla con los campos que hemos definido, junto con un id que es automático si no se define.
Podemos modificar el modelo sin problema, solo que hay que hacer la migraci´`on para que se guarden los cambios:
	python manage.py makemigrations
	python manage.py migration
Para no compremer la integridad de la DB, no debemos añadir campos que no pueden ser nulos después de haber creado la tabla, porque los que se hayan añadido
con anterioridad no van a estar rellenos. Para arreglar ese problema debemos añadir otro campo que puede ser, por ejemplo: null=True o añadir un valor por defecto: deafult=""

Los archivos.py que se generan con un número delante sirven para controlar la versión que va subiendo al sistema. Lo hace gracias a que una de las tabla que genera para funcionar es 
migration, donde guarda toda la evolución de la DB. Es muy útil porque podemos hacer un roll back para hacer algún cambio.


3.3. DELEGACIÓN DE RUTAS

Comprobamos el funcionamiento del modelado de datos en nuestra app.
Vemos como comunicamos todas las acciones a nuestro proyecto raíz manteniendo una modularización de nuestra estructura.
Una buena práctica es que cada aplicación contenga sus propias urls y hacer que el proyecto raíz sepa cómo acceder a ellos.

1. Dentro de la app (comentarios) creamos un archivo urls.py
2. Copiamos la estructura de la url.py general (modularizacion) y la dejamos limpia
3. Creamos una ruta de prueba, importamos views y creamos una vista junto con el template, solo un hola mundo para comprobar que el circuito funciona bien
4. Para que nuestro directrio general pueda leer las urls de las app, debemos hacer:
	- Importar la librería include: from django.urls import path, include
	- Crear el path de la carpeta de la app junto con el include:
		path('comments/', include('commentarios.urls')),





